{"version":3,"sources":["webpack:///main.a9cec8046ac1725eaa51.js","webpack:///./src/index.js","webpack:///./src/api/userApi.js","webpack:///./~/promise-polyfill/lib/index.js","webpack:///./~/timers-browserify/main.js","webpack:///./~/process/browser.js","webpack:///./src/api/baseUrl.js"],"names":["webpackJsonp","module","exports","__webpack_require__","global","_userApi","getUsers","then","result","usersBody","forEach","user","id","firstName","lastName","email","document","getElementById","innerHTML","deleteLinks","getElementsByClassName","Array","from","link","onclick","event","element","target","preventDefault","deleteUser","attributes","value","row","parentNode","removeChild","call","this","_interopRequireDefault","obj","__esModule","default","del","get","url","fetch","baseUrl","onSuccess","onError","request","Request","method","response","json","error","console","log","Object","defineProperty","_promisePolyfill","_promisePolyfill2","_baseUrl","_baseUrl2","window","Promise","setImmediate","noop","bind","fn","thisArg","apply","arguments","TypeError","_state","_handled","_value","undefined","_deferreds","doResolve","handle","self","deferred","push","_immediateFn","cb","onFulfilled","onRejected","resolve","reject","promise","ret","e","newValue","finale","length","_unhandledRejectionFn","i","len","Handler","done","reason","ex","setTimeoutFunc","setTimeout","prototype","prom","constructor","callback","all","arr","res","val","args","remaining","slice","race","values","err","warn","clearImmediate","Timeout","clearFn","_id","_clearFn","nextTick","Function","immediateIds","nextImmediateId","clearTimeout","setInterval","clearInterval","timeout","close","unref","ref","enroll","item","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","cleanUpNextTick","draining","currentQueue","queue","concat","queueIndex","drainQueue","run","Item","array","process","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","getBaseUrl","getQueryStringParameterByName","location","href","replace","regex","RegExp","results","exec","decodeURIComponent"],"mappings":"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","file":"main.a9cec8046ac1725eaa51.js","sourcesContent":["webpackJsonp([0],[\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\t__webpack_require__(1);\n\t\n\tvar _userApi = __webpack_require__(3);\n\t\n\t// Populate table of users via API call.\n\t(0, _userApi.getUsers)().then(function (result) {\n\t  var usersBody = \"\";\n\t\n\t  result.forEach(function (user) {\n\t    usersBody += '<tr>\\n      <td>' + user.id + '</td>\\n      <td>' + user.firstName + '</td>\\n      <td>' + user.lastName + '</td>\\n      <td>' + user.email + '</td>\\n      <td><a href=\"#\" data-id=\"' + user.id + '\" class=\"deleteUser\">Delete</a></td>\\n      </tr>';\n\t  });\n\t\n\t  global.document.getElementById('users').innerHTML = usersBody;\n\t\n\t  var deleteLinks = global.document.getElementsByClassName('deleteUser');\n\t\n\t  // Must use array.from to create a real array from a DOM collection\n\t  // getElementsByClassname only returns an \"array like\" object\n\t  Array.from(deleteLinks, function (link) {\n\t    link.onclick = function (event) {\n\t      var element = event.target;\n\t      event.preventDefault();\n\t      (0, _userApi.deleteUser)(element.attributes[\"data-id\"].value);\n\t      var row = element.parentNode.parentNode;\n\t      row.parentNode.removeChild(row);\n\t    };\n\t  });\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ },\n/* 2 */,\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.deleteUser = deleteUser;\n\texports.getUsers = getUsers;\n\t\n\t__webpack_require__(4);\n\t\n\tvar _promisePolyfill = __webpack_require__(5);\n\t\n\tvar _promisePolyfill2 = _interopRequireDefault(_promisePolyfill);\n\t\n\tvar _baseUrl = __webpack_require__(8);\n\t\n\tvar _baseUrl2 = _interopRequireDefault(_baseUrl);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar baseUrl = (0, _baseUrl2.default)();\n\t\n\t// To add to window\n\t/* This file is where we are centralize all our api calls. */\n\t\n\tif (!window.Promise) {\n\t  window.Promise = _promisePolyfill2.default;\n\t}\n\t\n\tfunction deleteUser(id) {\n\t  return del('users/' + id);\n\t}\n\t\n\tfunction getUsers() {\n\t  /* users is a term given in the url -  http://localhost:3000/*****users****** */\n\t  return get('users');\n\t}\n\t\n\tfunction get(url) {\n\t  /* baseUrl ends up being or / or http://localhost:3001 */\n\t  return fetch(baseUrl + url).then(onSuccess, onError);\n\t}\n\t\n\tfunction del(url) {\n\t  var request = new Request(baseUrl + url, {\n\t    method: 'DELETE'\n\t  });\n\t\n\t  return fetch(request).then(onSuccess, onError);\n\t}\n\t\n\tfunction onSuccess(response) {\n\t  return response.json();\n\t}\n\t\n\tfunction onError(error) {\n\t  console.log(error); // eslint-disable-line no-console\n\t}\n\n/***/ },\n/* 4 */,\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(setImmediate) {'use strict';\n\t\n\t// Store setTimeout reference so promise-polyfill will be unaffected by\n\t// other code modifying setTimeout (like sinon.useFakeTimers())\n\tvar setTimeoutFunc = setTimeout;\n\t\n\tfunction noop() {}\n\t\n\t// Polyfill for Function.prototype.bind\n\tfunction bind(fn, thisArg) {\n\t  return function() {\n\t    fn.apply(thisArg, arguments);\n\t  };\n\t}\n\t\n\tfunction Promise(fn) {\n\t  if (!(this instanceof Promise))\n\t    throw new TypeError('Promises must be constructed via new');\n\t  if (typeof fn !== 'function') throw new TypeError('not a function');\n\t  this._state = 0;\n\t  this._handled = false;\n\t  this._value = undefined;\n\t  this._deferreds = [];\n\t\n\t  doResolve(fn, this);\n\t}\n\t\n\tfunction handle(self, deferred) {\n\t  while (self._state === 3) {\n\t    self = self._value;\n\t  }\n\t  if (self._state === 0) {\n\t    self._deferreds.push(deferred);\n\t    return;\n\t  }\n\t  self._handled = true;\n\t  Promise._immediateFn(function() {\n\t    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n\t    if (cb === null) {\n\t      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n\t      return;\n\t    }\n\t    var ret;\n\t    try {\n\t      ret = cb(self._value);\n\t    } catch (e) {\n\t      reject(deferred.promise, e);\n\t      return;\n\t    }\n\t    resolve(deferred.promise, ret);\n\t  });\n\t}\n\t\n\tfunction resolve(self, newValue) {\n\t  try {\n\t    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n\t    if (newValue === self)\n\t      throw new TypeError('A promise cannot be resolved with itself.');\n\t    if (\n\t      newValue &&\n\t      (typeof newValue === 'object' || typeof newValue === 'function')\n\t    ) {\n\t      var then = newValue.then;\n\t      if (newValue instanceof Promise) {\n\t        self._state = 3;\n\t        self._value = newValue;\n\t        finale(self);\n\t        return;\n\t      } else if (typeof then === 'function') {\n\t        doResolve(bind(then, newValue), self);\n\t        return;\n\t      }\n\t    }\n\t    self._state = 1;\n\t    self._value = newValue;\n\t    finale(self);\n\t  } catch (e) {\n\t    reject(self, e);\n\t  }\n\t}\n\t\n\tfunction reject(self, newValue) {\n\t  self._state = 2;\n\t  self._value = newValue;\n\t  finale(self);\n\t}\n\t\n\tfunction finale(self) {\n\t  if (self._state === 2 && self._deferreds.length === 0) {\n\t    Promise._immediateFn(function() {\n\t      if (!self._handled) {\n\t        Promise._unhandledRejectionFn(self._value);\n\t      }\n\t    });\n\t  }\n\t\n\t  for (var i = 0, len = self._deferreds.length; i < len; i++) {\n\t    handle(self, self._deferreds[i]);\n\t  }\n\t  self._deferreds = null;\n\t}\n\t\n\tfunction Handler(onFulfilled, onRejected, promise) {\n\t  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n\t  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n\t  this.promise = promise;\n\t}\n\t\n\t/**\n\t * Take a potentially misbehaving resolver function and make sure\n\t * onFulfilled and onRejected are only called once.\n\t *\n\t * Makes no guarantees about asynchrony.\n\t */\n\tfunction doResolve(fn, self) {\n\t  var done = false;\n\t  try {\n\t    fn(\n\t      function(value) {\n\t        if (done) return;\n\t        done = true;\n\t        resolve(self, value);\n\t      },\n\t      function(reason) {\n\t        if (done) return;\n\t        done = true;\n\t        reject(self, reason);\n\t      }\n\t    );\n\t  } catch (ex) {\n\t    if (done) return;\n\t    done = true;\n\t    reject(self, ex);\n\t  }\n\t}\n\t\n\tPromise.prototype['catch'] = function(onRejected) {\n\t  return this.then(null, onRejected);\n\t};\n\t\n\tPromise.prototype.then = function(onFulfilled, onRejected) {\n\t  var prom = new this.constructor(noop);\n\t\n\t  handle(this, new Handler(onFulfilled, onRejected, prom));\n\t  return prom;\n\t};\n\t\n\tPromise.prototype['finally'] = function(callback) {\n\t  var constructor = this.constructor;\n\t  return this.then(\n\t    function(value) {\n\t      return constructor.resolve(callback()).then(function() {\n\t        return value;\n\t      });\n\t    },\n\t    function(reason) {\n\t      return constructor.resolve(callback()).then(function() {\n\t        return constructor.reject(reason);\n\t      });\n\t    }\n\t  );\n\t};\n\t\n\tPromise.all = function(arr) {\n\t  return new Promise(function(resolve, reject) {\n\t    if (!arr || typeof arr.length === 'undefined')\n\t      throw new TypeError('Promise.all accepts an array');\n\t    var args = Array.prototype.slice.call(arr);\n\t    if (args.length === 0) return resolve([]);\n\t    var remaining = args.length;\n\t\n\t    function res(i, val) {\n\t      try {\n\t        if (val && (typeof val === 'object' || typeof val === 'function')) {\n\t          var then = val.then;\n\t          if (typeof then === 'function') {\n\t            then.call(\n\t              val,\n\t              function(val) {\n\t                res(i, val);\n\t              },\n\t              reject\n\t            );\n\t            return;\n\t          }\n\t        }\n\t        args[i] = val;\n\t        if (--remaining === 0) {\n\t          resolve(args);\n\t        }\n\t      } catch (ex) {\n\t        reject(ex);\n\t      }\n\t    }\n\t\n\t    for (var i = 0; i < args.length; i++) {\n\t      res(i, args[i]);\n\t    }\n\t  });\n\t};\n\t\n\tPromise.resolve = function(value) {\n\t  if (value && typeof value === 'object' && value.constructor === Promise) {\n\t    return value;\n\t  }\n\t\n\t  return new Promise(function(resolve) {\n\t    resolve(value);\n\t  });\n\t};\n\t\n\tPromise.reject = function(value) {\n\t  return new Promise(function(resolve, reject) {\n\t    reject(value);\n\t  });\n\t};\n\t\n\tPromise.race = function(values) {\n\t  return new Promise(function(resolve, reject) {\n\t    for (var i = 0, len = values.length; i < len; i++) {\n\t      values[i].then(resolve, reject);\n\t    }\n\t  });\n\t};\n\t\n\t// Use polyfill for setImmediate for performance gains\n\tPromise._immediateFn =\n\t  (typeof setImmediate === 'function' &&\n\t    function(fn) {\n\t      setImmediate(fn);\n\t    }) ||\n\t  function(fn) {\n\t    setTimeoutFunc(fn, 0);\n\t  };\n\t\n\tPromise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n\t  if (typeof console !== 'undefined' && console) {\n\t    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n\t  }\n\t};\n\t\n\tmodule.exports = Promise;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6).setImmediate))\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(7).nextTick;\n\tvar apply = Function.prototype.apply;\n\tvar slice = Array.prototype.slice;\n\tvar immediateIds = {};\n\tvar nextImmediateId = 0;\n\t\n\t// DOM APIs, for completeness\n\t\n\texports.setTimeout = function() {\n\t  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n\t};\n\texports.setInterval = function() {\n\t  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n\t};\n\texports.clearTimeout =\n\texports.clearInterval = function(timeout) { timeout.close(); };\n\t\n\tfunction Timeout(id, clearFn) {\n\t  this._id = id;\n\t  this._clearFn = clearFn;\n\t}\n\tTimeout.prototype.unref = Timeout.prototype.ref = function() {};\n\tTimeout.prototype.close = function() {\n\t  this._clearFn.call(window, this._id);\n\t};\n\t\n\t// Does not start the time, just sets up the members needed.\n\texports.enroll = function(item, msecs) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = msecs;\n\t};\n\t\n\texports.unenroll = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = -1;\n\t};\n\t\n\texports._unrefActive = exports.active = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t\n\t  var msecs = item._idleTimeout;\n\t  if (msecs >= 0) {\n\t    item._idleTimeoutId = setTimeout(function onTimeout() {\n\t      if (item._onTimeout)\n\t        item._onTimeout();\n\t    }, msecs);\n\t  }\n\t};\n\t\n\t// That's not how node.js implements it but the exposed api is the same.\n\texports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n\t  var id = nextImmediateId++;\n\t  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\t\n\t  immediateIds[id] = true;\n\t\n\t  nextTick(function onNextTick() {\n\t    if (immediateIds[id]) {\n\t      // fn.call() is faster so we optimize for the common use-case\n\t      // @see http://jsperf.com/call-apply-segu\n\t      if (args) {\n\t        fn.apply(null, args);\n\t      } else {\n\t        fn.call(null);\n\t      }\n\t      // Prevent ids from leaking\n\t      exports.clearImmediate(id);\n\t    }\n\t  });\n\t\n\t  return id;\n\t};\n\t\n\texports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n\t  delete immediateIds[id];\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6).setImmediate, __webpack_require__(6).clearImmediate))\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\tprocess.prependListener = noop;\n\tprocess.prependOnceListener = noop;\n\t\n\tprocess.listeners = function (name) { return [] }\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = getBaseUrl;\n\t/*  Original Code\n\texport default function getBaseUrl(){\n\t    const inDevelopment = window.location.hostname === 'localhost';\n\t    return inDevelopment ? 'http://localhost:3001/': '/';\n\t}\n\t*/\n\t\n\tfunction getBaseUrl() {\n\t  return getQueryStringParameterByName('useMockApi') ? 'http://localhost:3001/' : '/';\n\t}\n\t\n\t//  you can use jquery for this\n\tfunction getQueryStringParameterByName(name, url) {\n\t  if (!url) url = window.location.href;\n\t  name = name.replace(/[\\[\\]]/g, \"\\\\$&\");\n\t  var regex = new RegExp(\"[?&]\" + name + \"(=([^&#]*)|&|#|$)\"),\n\t      results = regex.exec(url);\n\t  if (!results) return null;\n\t  if (!results[2]) return '';\n\t  return decodeURIComponent(results[2].replace(/\\+/g, \" \"));\n\t}\n\n/***/ }\n]);\n\n\n/** WEBPACK FOOTER **\n ** main.a9cec8046ac1725eaa51.js\n **/","import './index.css';\nimport {getUsers, deleteUser} from './api/userApi';\n\n\n\n// Populate table of users via API call.\ngetUsers().then(result => {\n  let usersBody = \"\";\n\n  result.forEach(user => {\n    usersBody+= `<tr>\n      <td>${user.id}</td>\n      <td>${user.firstName}</td>\n      <td>${user.lastName}</td>\n      <td>${user.email}</td>\n      <td><a href=\"#\" data-id=\"${user.id}\" class=\"deleteUser\">Delete</a></td>\n      </tr>`\n  });\n\n  global.document.getElementById('users').innerHTML = usersBody;\n\n const deleteLinks = global.document.getElementsByClassName('deleteUser');\n\n  // Must use array.from to create a real array from a DOM collection\n  // getElementsByClassname only returns an \"array like\" object\n  Array.from(deleteLinks, link => {\n    link.onclick = function(event) {\n      const element = event.target;\n      event.preventDefault();\n      deleteUser(element.attributes[\"data-id\"].value);\n      const row = element.parentNode.parentNode;\n      row.parentNode.removeChild(row);\n    };\n  });\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","/* This file is where we are centralize all our api calls. */\n\nimport 'whatwg-fetch';\nimport Promise from 'promise-polyfill';\nimport getBaseUrl from './baseUrl';\n\nconst baseUrl = getBaseUrl();\n\n// To add to window\nif (!window.Promise) {\n  window.Promise = Promise;\n}\n\nexport function deleteUser(id) {\n  return del(`users/${id}`);\n}\n\nexport function getUsers() {\n/* users is a term given in the url -  http://localhost:3000/*****users****** */\n  return get('users');\n}\n\nfunction get(url) {\n/* baseUrl ends up being or / or http://localhost:3001 */\n  return fetch(baseUrl + url).then(onSuccess, onError);\n}\n\nfunction del(url) {\n  const request = new Request(baseUrl + url, {\n    method: 'DELETE'\n  });\n\n  return fetch(request).then(onSuccess, onError);\n}\n\nfunction onSuccess(response) {\n  return response.json();\n}\n\nfunction onError(error) {\n  console.log(error); // eslint-disable-line no-console\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/api/userApi.js\n **/","'use strict';\n\n// Store setTimeout reference so promise-polyfill will be unaffected by\n// other code modifying setTimeout (like sinon.useFakeTimers())\nvar setTimeoutFunc = setTimeout;\n\nfunction noop() {}\n\n// Polyfill for Function.prototype.bind\nfunction bind(fn, thisArg) {\n  return function() {\n    fn.apply(thisArg, arguments);\n  };\n}\n\nfunction Promise(fn) {\n  if (!(this instanceof Promise))\n    throw new TypeError('Promises must be constructed via new');\n  if (typeof fn !== 'function') throw new TypeError('not a function');\n  this._state = 0;\n  this._handled = false;\n  this._value = undefined;\n  this._deferreds = [];\n\n  doResolve(fn, this);\n}\n\nfunction handle(self, deferred) {\n  while (self._state === 3) {\n    self = self._value;\n  }\n  if (self._state === 0) {\n    self._deferreds.push(deferred);\n    return;\n  }\n  self._handled = true;\n  Promise._immediateFn(function() {\n    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n      return;\n    }\n    var ret;\n    try {\n      ret = cb(self._value);\n    } catch (e) {\n      reject(deferred.promise, e);\n      return;\n    }\n    resolve(deferred.promise, ret);\n  });\n}\n\nfunction resolve(self, newValue) {\n  try {\n    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n    if (newValue === self)\n      throw new TypeError('A promise cannot be resolved with itself.');\n    if (\n      newValue &&\n      (typeof newValue === 'object' || typeof newValue === 'function')\n    ) {\n      var then = newValue.then;\n      if (newValue instanceof Promise) {\n        self._state = 3;\n        self._value = newValue;\n        finale(self);\n        return;\n      } else if (typeof then === 'function') {\n        doResolve(bind(then, newValue), self);\n        return;\n      }\n    }\n    self._state = 1;\n    self._value = newValue;\n    finale(self);\n  } catch (e) {\n    reject(self, e);\n  }\n}\n\nfunction reject(self, newValue) {\n  self._state = 2;\n  self._value = newValue;\n  finale(self);\n}\n\nfunction finale(self) {\n  if (self._state === 2 && self._deferreds.length === 0) {\n    Promise._immediateFn(function() {\n      if (!self._handled) {\n        Promise._unhandledRejectionFn(self._value);\n      }\n    });\n  }\n\n  for (var i = 0, len = self._deferreds.length; i < len; i++) {\n    handle(self, self._deferreds[i]);\n  }\n  self._deferreds = null;\n}\n\nfunction Handler(onFulfilled, onRejected, promise) {\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, self) {\n  var done = false;\n  try {\n    fn(\n      function(value) {\n        if (done) return;\n        done = true;\n        resolve(self, value);\n      },\n      function(reason) {\n        if (done) return;\n        done = true;\n        reject(self, reason);\n      }\n    );\n  } catch (ex) {\n    if (done) return;\n    done = true;\n    reject(self, ex);\n  }\n}\n\nPromise.prototype['catch'] = function(onRejected) {\n  return this.then(null, onRejected);\n};\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  var prom = new this.constructor(noop);\n\n  handle(this, new Handler(onFulfilled, onRejected, prom));\n  return prom;\n};\n\nPromise.prototype['finally'] = function(callback) {\n  var constructor = this.constructor;\n  return this.then(\n    function(value) {\n      return constructor.resolve(callback()).then(function() {\n        return value;\n      });\n    },\n    function(reason) {\n      return constructor.resolve(callback()).then(function() {\n        return constructor.reject(reason);\n      });\n    }\n  );\n};\n\nPromise.all = function(arr) {\n  return new Promise(function(resolve, reject) {\n    if (!arr || typeof arr.length === 'undefined')\n      throw new TypeError('Promise.all accepts an array');\n    var args = Array.prototype.slice.call(arr);\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n\n    function res(i, val) {\n      try {\n        if (val && (typeof val === 'object' || typeof val === 'function')) {\n          var then = val.then;\n          if (typeof then === 'function') {\n            then.call(\n              val,\n              function(val) {\n                res(i, val);\n              },\n              reject\n            );\n            return;\n          }\n        }\n        args[i] = val;\n        if (--remaining === 0) {\n          resolve(args);\n        }\n      } catch (ex) {\n        reject(ex);\n      }\n    }\n\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.resolve = function(value) {\n  if (value && typeof value === 'object' && value.constructor === Promise) {\n    return value;\n  }\n\n  return new Promise(function(resolve) {\n    resolve(value);\n  });\n};\n\nPromise.reject = function(value) {\n  return new Promise(function(resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function(values) {\n  return new Promise(function(resolve, reject) {\n    for (var i = 0, len = values.length; i < len; i++) {\n      values[i].then(resolve, reject);\n    }\n  });\n};\n\n// Use polyfill for setImmediate for performance gains\nPromise._immediateFn =\n  (typeof setImmediate === 'function' &&\n    function(fn) {\n      setImmediate(fn);\n    }) ||\n  function(fn) {\n    setTimeoutFunc(fn, 0);\n  };\n\nPromise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n  if (typeof console !== 'undefined' && console) {\n    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n  }\n};\n\nmodule.exports = Promise;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/promise-polyfill/lib/index.js\n ** module id = 5\n ** module chunks = 0\n **/","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/timers-browserify/main.js\n ** module id = 6\n ** module chunks = 0\n **/","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/process/browser.js\n ** module id = 7\n ** module chunks = 0\n **/","/*  Original Code\nexport default function getBaseUrl(){\n    const inDevelopment = window.location.hostname === 'localhost';\n    return inDevelopment ? 'http://localhost:3001/': '/';\n}\n*/\n\nexport default function getBaseUrl() {\n  return getQueryStringParameterByName('useMockApi') ? 'http://localhost:3001/' : '/';\n}\n\n\n//  you can use jquery for this\nfunction getQueryStringParameterByName(name, url) {\n  if (!url) url = window.location.href;\n  name = name.replace(/[\\[\\]]/g, \"\\\\$&\");\n  var regex = new RegExp(\"[?&]\" + name + \"(=([^&#]*)|&|#|$)\"),\n      results = regex.exec(url);\n  if (!results) return null;\n  if (!results[2]) return '';\n  return decodeURIComponent(results[2].replace(/\\+/g, \" \"));\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/api/baseUrl.js\n **/"],"sourceRoot":""}